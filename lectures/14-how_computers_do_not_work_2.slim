= slide 'Въпрос 1' do

  p.action Какво е ОС? Избройте 2 ключови неща, които тя трябва да прави.
  br
  p.action ОС е парче софтуер, което менажира хардуера и управлява потребителски процеси.


= slide 'Въпрос 2' do

  p.action Какво е kernel, drivers, userland?
  br
  p.action Ядрото е това, което има достъп до (почти) всичкия хардуер, всичко в ОС-а и което се грижи за потребителските процеси.
  p.action Драйвърите са код, който е чужд за ОС-а, който управлява конкретен вид хардуер.
  p.action Юзърленд-а са потребителски програми, без които една ОС би била безполезна.


= slide 'Въпрос 3' do

  p.action Какво са Kernel space и User space и защо съществуват?
  br
  p.action Първото е "привилегированата" част на една ОС.
  p.action Второто е там, където вървят потребителските процеси.
  p.action Това се прави за сигурнст - процесите да не се достъпват помежду си, както и да не омажат ядрото.


= slide 'Въпрос 4' do

  p.action Какво е процес?
  br
  p.action Абстракция за виртуална памет. Това е една потребителска програма, която има собствена памет.


= slide 'Въпрос 5' do

  p.action Как (едно време) се е минавала границата User space / Kernel space?
  br
  p.action Интеръпти.


= slide 'Въпрос 6' do

  p.action Какви сегменти има в паметта на един процес?
  br
  p.action Image files (code)
  p.action Stacks
  p.action Heaps
  p.action Static data
  p.action etc


= slide 'Изпълнимите файлове на твърдия диск' do

  p.action Съдържа кода на приложението
  p.action Може да съдържа кода на външни библиотеки
  p.action Или просто имената на тези външни зависимости
  p.action Примерна зависмист е стандартната С библиотека


= slide 'Как получаваме изпълними файлове?' do

  p.action Чрез компилация и линкване
  p.action Компилацията превежда отделен файл с програмен код към машинни инструкции
  p.action Линкването "свързва" отделни компилирани единици
  p.action Какво правим с външни зависимости, които не са наш код?
  p.action Като например printf от стандартната С библиотека?


= slide 'Static linking' do

  p Когато кодът на нужните библиотеки е в изпълнимия файл


= slide 'Dynamic linking' do

  p.action В изпълнимия файл има единствено имена на библиотеки и функции
  p.action Пример: libc.so:printf или msvcrt.dll:printf
  p.action ОС-а се грижи да "зареди" библиотеката и да навърже адресите


= slide 'static VS dynamic linking' do

  p.action По-големи изпълними файлове при статично линкване
  p.action Малко по-бързо изпъленение при статично линкване
  p.action Няма споделяне на код в обща библиотека при статично линкване


= slide 'Изпълнение на код' do

  p.action Компютрите "говорят" на машинен език
  p.action Ние програмираме на човешко-четим език
  p.action Трябва някой по някакъв начин трябва да го обърне до машинен, за да може да бъде изпълнен от компютъра
  p.action Има (грубо-казано) 2 начина за това


= slide 'Compilation / Interpretation' do

  p.action При първия, една програма "превежда" човешкия език на машинен преди изпълнението му
  p.action Тя се нарича компилатор
  p.action Включва процеса на linking, за който говорихме предния път

  p.action При втория, една програма директно изпълнява човешкия език
  p.action Тя се нарича интерпретатор
  p.action Работи на принципа read-eval-print (REPL)


= slide 'Плюсове и минуси' do

  p.action Компилацията отнема време (C++, anyone?)
  p.action Компилираният код се изпълнява по-бързо
  p.action Времето за зареждане на интерпретиран код може да е голямо
  p.action Интерпретируемите езици нямат нужда от build системи
  p.action По-често (и лесно) се ползват за rapid prototyping
  p.action Компилираният код остава същия през времето
  p.action Това може да е проблем, когато хардуерът става по-добър


= slide 'JIT' do

  p.action Идеята е да компилираме човешкия език до междинен код (Java bytecode, MSIL)
  p.action Който после, по време на изпълнение, се компилира до машинен
  p.action Това, което прави вторичната компилация, се нарича runtime
  p.action Типичните примери за това са .NET/Java


= slide 'Плюсове и минуси' do

  p.action По-бавен startup time, тъй като се налага междинния код да се транслира
  p.action Евентуално по-бързо изпълнение от чист native код по две причини:
  p.action При дълго вървящи процеси, runtime-ът може да оптимизира hot paths
  p.action Когато upgrade-нем хардуера и runtime-а, всички "стари" програми ще вървят по-бързо
  p.action Доста повече метаинформация, идваща от runtime-a
  p.action Благинки като garbage-collection, reflection


= slide 'Виртуални машини' do

  p Междинният код се изпълнява от нещо наречено виртуална машина (JVM/CLR)
  p.action Обикновено използват JIT
  p.action Някои могат да интерпретират междинния код
  p.action Някои могат да правят и двете (JVM)


= slide 'Python' do

  p Къде се намира Python в картинката
  p.action Има bytecode
  p.action Няма JIT; винаги се интерпретира
  p.action Кешира се в .pyc файлове


= slide 'Python (2)' do

  p В известен смисъл е виртуална машина
  p.action Имплементиран е на C
  p.action Части от стандартната библиотека са DLL-ове написани на C


= slide 'Какво съдържа един native DLL/so' do

  p.action Практически няма разлика между DLL и EXE
  p.action Съдържа изпълним код, import таблица, export таблица
  p.action Последната съдържа само имената на функциите за C DLL-и
  p.action За C++ такива съдържа в името си и имената на типовете на аргументите си
  p.action Не съдържат, обаче, дефиниции на типове
  p.action Как тогава можем да компилираме код, който използва функции от такива DLL-и?


= slide 'В чисто C и C++' do

  p.action С header файлове. Те съдържат дефинициите на типове, декларации на функции и т.н.


= slide 'В Java/.NET' do

  p.action Java използва JAR файлове, а в .NET DLL-ите не са (просто) native такива
  p.action В тях има много метаинформация за всички типове, функции, etc


= slide 'Скриптовите езици' do

  p.action Те обикновено не се компилират, а интерпретират, което означава, че ship-ват код
  p.action Тогава нямаме проблем с липса на типова информация


= slide 'Memory management' do

  p.action Всяка програма работи с променливи, които се намират някъде в оперативната памет
  p.action Има няколко подхода за това къде може да се намират
  p.action В read-only паметта, например хардкоднати стойности в кода ни
  p.action На стека, ако това са локални променливи във функции, например
  p.action В heap-a, ако са променливи, които ще ни трябват по-продължително
  p.action За последните някой трябва да се грижи ръчно кога да бъдат освободени


= slide 'Manual memory management' do

  p.action Езици като C/C++
  p.action Това е най-бързото решение като скорост на изпълнение
  p.action Освобождаваме ресурси максимално бързо, когато не ни трябват
  p.action Стават МНОГО грешки
  p.action Причината за 90% от crash-овете на приложения


= slide 'Garbage collection' do

  p.action По-модерни езици като Java/.NET/Ruby/Go
  p.action По-бавно по време на изпълнение
  p.action По-късно освобождаване на ресурси
  p.action Но пък е programmer-proof
